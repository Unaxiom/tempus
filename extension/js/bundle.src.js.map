{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/js/commons.js","src/js/main.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvhBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"bundle.src.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","\"use strict\";\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [0, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**Stores the list of URLs */\r\nexports.tempusObjectID = \"tempusArray\";\r\nexports.tempusRefresherID = \"tempusRefresher\";\r\nexports.refreshDelayInMins = (1 / 60);\r\nvar refreshDelayInMilliSeconds = exports.refreshDelayInMins * 60 * 1000;\r\nexports.refreshAlarm = \"Alarm\";\r\nvar firefoxBrowser = 'firefox';\r\nvar chromeBrowser = 'chrome';\r\nvar browserName;\r\nif (navigator.userAgent.indexOf(\"Chrome\") > -1) {\r\n    browserName = chromeBrowser;\r\n}\r\nelse {\r\n    browserName = firefoxBrowser;\r\n}\r\n// let browser = chrome;\r\n/**Retrieves the storage value */\r\nfunction getStorage() {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    if (!(browserName == firefoxBrowser)) return [3 /*break*/, 2];\r\n                    return [4 /*yield*/, browser.storage.local.get()];\r\n                case 1: return [2 /*return*/, _a.sent()];\r\n                case 2:\r\n                    if (browserName == chromeBrowser) {\r\n                        return [2 /*return*/, new Promise(function (resolve, reject) {\r\n                                try {\r\n                                    chrome.storage.local.get(function (items) {\r\n                                        resolve(items);\r\n                                    });\r\n                                }\r\n                                catch (e) {\r\n                                    reject(e);\r\n                                }\r\n                            })];\r\n                    }\r\n                    _a.label = 3;\r\n                case 3: return [2 /*return*/, {}];\r\n            }\r\n        });\r\n    });\r\n}\r\n/**Sets the storage */\r\nfunction setStorage(storageObject) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    if (!(browserName == firefoxBrowser)) return [3 /*break*/, 2];\r\n                    return [4 /*yield*/, browser.storage.local.set(storageObject)];\r\n                case 1:\r\n                    _a.sent();\r\n                    return [3 /*break*/, 3];\r\n                case 2:\r\n                    if (browserName == chromeBrowser) {\r\n                        return [2 /*return*/, new Promise(function (resolve, reject) {\r\n                                try {\r\n                                    chrome.storage.local.set(storageObject, function () {\r\n                                        resolve();\r\n                                    });\r\n                                }\r\n                                catch (e) {\r\n                                    reject(e);\r\n                                }\r\n                            })];\r\n                    }\r\n                    _a.label = 3;\r\n                case 3: return [2 /*return*/];\r\n            }\r\n        });\r\n    });\r\n}\r\n/**Clears the storage */\r\nfunction clearStorage() {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    if (!(browserName == firefoxBrowser)) return [3 /*break*/, 2];\r\n                    return [4 /*yield*/, browser.storage.local.clear()];\r\n                case 1:\r\n                    _a.sent();\r\n                    return [3 /*break*/, 3];\r\n                case 2:\r\n                    if (browserName == chromeBrowser) {\r\n                        return [2 /*return*/, new Promise(function (resolve, reject) {\r\n                                try {\r\n                                    chrome.storage.local.clear(function () {\r\n                                        resolve();\r\n                                    });\r\n                                }\r\n                                catch (e) {\r\n                                    reject(e);\r\n                                }\r\n                            })];\r\n                    }\r\n                    _a.label = 3;\r\n                case 3: return [2 /*return*/];\r\n            }\r\n        });\r\n    });\r\n}\r\n/**Adds an alarm to the appropriate browser */\r\nfunction createBrowserAlarm(alarmName, obj, listener) {\r\n    if (browserName == firefoxBrowser) {\r\n        browser.alarms.create(alarmName, obj);\r\n        browser.alarms.onAlarm.addListener(listener);\r\n    }\r\n    else if (browserName == chromeBrowser) {\r\n        chrome.alarms.create(alarmName, obj);\r\n        chrome.alarms.onAlarm.addListener(listener);\r\n    }\r\n}\r\n/**Clears the browser alarm */\r\nfunction clearBrowserAlarm(alarmName) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    if (!(browserName == firefoxBrowser)) return [3 /*break*/, 2];\r\n                    return [4 /*yield*/, browser.alarms.clear(alarmName)];\r\n                case 1:\r\n                    _a.sent();\r\n                    return [3 /*break*/, 3];\r\n                case 2:\r\n                    if (browserName == chromeBrowser) {\r\n                        return [2 /*return*/, new Promise(function (resolve, reject) {\r\n                                try {\r\n                                    chrome.alarms.clear(alarmName, function (wasCleared) {\r\n                                        resolve();\r\n                                    });\r\n                                }\r\n                                catch (e) {\r\n                                    reject(e);\r\n                                }\r\n                            })];\r\n                    }\r\n                    _a.label = 3;\r\n                case 3: return [2 /*return*/];\r\n            }\r\n        });\r\n    });\r\n}\r\n/**Returns all the browser tabs on the basis of the query object */\r\nfunction queryBrowserTabs(obj) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    if (!(browserName == firefoxBrowser)) return [3 /*break*/, 2];\r\n                    return [4 /*yield*/, browser.tabs.query(obj)];\r\n                case 1: return [2 /*return*/, _a.sent()];\r\n                case 2:\r\n                    if (browserName == chromeBrowser) {\r\n                        return [2 /*return*/, new Promise(function (resolve, reject) {\r\n                                try {\r\n                                    chrome.tabs.query(obj, function (result) {\r\n                                        resolve(result);\r\n                                    });\r\n                                }\r\n                                catch (e) {\r\n                                    reject(e);\r\n                                }\r\n                            })];\r\n                    }\r\n                    _a.label = 3;\r\n                case 3: return [2 /*return*/, []];\r\n            }\r\n        });\r\n    });\r\n}\r\nexports.queryBrowserTabs = queryBrowserTabs;\r\n/**Attaches the event handler that is fired when a tab is activated */\r\nfunction addBrowserTabsOnActivatedHandler(callback) {\r\n    if (browserName == firefoxBrowser) {\r\n        browser.tabs.onActivated.addListener(callback);\r\n    }\r\n    else if (browserName == chromeBrowser) {\r\n        chrome.tabs.onActivated.addListener(callback);\r\n    }\r\n}\r\nexports.addBrowserTabsOnActivatedHandler = addBrowserTabsOnActivatedHandler;\r\n/**Attaches the event handler that is fired when a tab is removed */\r\nfunction addBrowserTabsOnRemovedHandler(callback) {\r\n    if (browserName == firefoxBrowser) {\r\n        browser.tabs.onRemoved.addListener(callback);\r\n    }\r\n    else if (browserName == chromeBrowser) {\r\n        chrome.tabs.onRemoved.addListener(callback);\r\n    }\r\n}\r\nexports.addBrowserTabsOnRemovedHandler = addBrowserTabsOnRemovedHandler;\r\n/**Attaches the event handler that is fired when a tab is updated */\r\nfunction addBrowserTabsOnUpdatedHandler(callback) {\r\n    if (browserName == firefoxBrowser) {\r\n        browser.tabs.onUpdated.addListener(callback);\r\n    }\r\n    else if (browserName == chromeBrowser) {\r\n        chrome.tabs.onUpdated.addListener(callback);\r\n    }\r\n}\r\nexports.addBrowserTabsOnUpdatedHandler = addBrowserTabsOnUpdatedHandler;\r\n/**Returns the tempus object */\r\nfunction fetchTempusObject() {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var storageObject;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0: return [4 /*yield*/, getStorage()];\r\n                case 1:\r\n                    storageObject = _a.sent();\r\n                    if (!!storageObject[exports.tempusObjectID]) return [3 /*break*/, 3];\r\n                    storageObject[exports.tempusObjectID] = {\r\n                        id: exports.tempusObjectID,\r\n                        tempusArray: []\r\n                    };\r\n                    // Write the object to the storage\r\n                    return [4 /*yield*/, setStorage(storageObject)];\r\n                case 2:\r\n                    // Write the object to the storage\r\n                    _a.sent();\r\n                    _a.label = 3;\r\n                case 3: return [4 /*yield*/, getStorage()];\r\n                case 4:\r\n                    storageObject = _a.sent();\r\n                    return [2 /*return*/, storageObject[exports.tempusObjectID]];\r\n            }\r\n        });\r\n    });\r\n}\r\nexports.fetchTempusObject = fetchTempusObject;\r\n/**Returns the tempus refresher object */\r\nfunction fetchTempusRefresher() {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var storageObject;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0: return [4 /*yield*/, getStorage()];\r\n                case 1:\r\n                    storageObject = _a.sent();\r\n                    if (!!storageObject[exports.tempusRefresherID]) return [3 /*break*/, 3];\r\n                    storageObject[exports.tempusRefresherID] = {\r\n                        id: exports.tempusRefresherID,\r\n                        refreshed_at: 0\r\n                    };\r\n                    // Write the object to the storage\r\n                    return [4 /*yield*/, setStorage(storageObject)];\r\n                case 2:\r\n                    // Write the object to the storage\r\n                    _a.sent();\r\n                    _a.label = 3;\r\n                case 3: return [4 /*yield*/, getStorage()];\r\n                case 4:\r\n                    storageObject = _a.sent();\r\n                    return [2 /*return*/, storageObject[exports.tempusRefresherID]];\r\n            }\r\n        });\r\n    });\r\n}\r\nexports.fetchTempusRefresher = fetchTempusRefresher;\r\n/**Checks if there are any unclosed tabs and closes them */\r\nfunction closePreviouslyUnclosedTabs() {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var tempusObject, tempusRefresher, currentTimestamp, timeDelay;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0: return [4 /*yield*/, fetchTempusObject()];\r\n                case 1:\r\n                    tempusObject = _a.sent();\r\n                    return [4 /*yield*/, fetchTempusRefresher()];\r\n                case 2:\r\n                    tempusRefresher = _a.sent();\r\n                    currentTimestamp = new Date().getTime();\r\n                    if (tempusRefresher.refreshed_at <= 0) {\r\n                        // This is the first time this is running\r\n                        return [2 /*return*/];\r\n                    }\r\n                    timeDelay = currentTimestamp - tempusRefresher.refreshed_at;\r\n                    /* Iterate over all the available tempus objects and set their active to false,\r\n                    /* and increase their duration by refreshDelayInMins * 6000\r\n                    */\r\n                    tempusObject.tempusArray.forEach(function (tempusStruct) {\r\n                        if (tempusStruct.active) {\r\n                            tempusStruct.active = false;\r\n                            if (timeDelay > refreshDelayInMilliSeconds) {\r\n                                // If time delay is greater, then the max increment can be the refresh delay\r\n                                tempusStruct.lapsed += refreshDelayInMilliSeconds;\r\n                            }\r\n                            else {\r\n                                // If time delay is lower, then set it to time delay\r\n                                tempusStruct.lapsed += timeDelay;\r\n                            }\r\n                        }\r\n                    });\r\n                    return [4 /*yield*/, storeTempusObject(tempusObject)];\r\n                case 3:\r\n                    _a.sent();\r\n                    return [4 /*yield*/, storeTempusRefresher(tempusRefresher)];\r\n                case 4:\r\n                    _a.sent();\r\n                    return [2 /*return*/];\r\n            }\r\n        });\r\n    });\r\n}\r\nexports.closePreviouslyUnclosedTabs = closePreviouslyUnclosedTabs;\r\n/**Returns domain from a passed URL */\r\nfunction returnDomainFromURL(url) {\r\n    var domain = '';\r\n    if (!url) {\r\n        return domain;\r\n    }\r\n    if (url.startsWith(\"http\")) {\r\n        var temp = url.split(\"//\");\r\n        domain = temp[0] + \"//\" + temp[1].split(\"/\")[0];\r\n    }\r\n    else {\r\n        domain = url;\r\n    }\r\n    return domain;\r\n}\r\nexports.returnDomainFromURL = returnDomainFromURL;\r\n/**Stores the tempus object in the storage */\r\nfunction storeTempusObject(obj) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var localObj;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    localObj = {};\r\n                    localObj[exports.tempusObjectID] = obj;\r\n                    return [4 /*yield*/, setStorage(localObj)];\r\n                case 1:\r\n                    _a.sent();\r\n                    return [2 /*return*/];\r\n            }\r\n        });\r\n    });\r\n}\r\nexports.storeTempusObject = storeTempusObject;\r\n/**Stores the tempus refresher in the storage */\r\nfunction storeTempusRefresher(obj) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var localObj;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    localObj = {};\r\n                    localObj[exports.tempusRefresherID] = obj;\r\n                    return [4 /*yield*/, setStorage(localObj)];\r\n                case 1:\r\n                    _a.sent();\r\n                    return [2 /*return*/];\r\n            }\r\n        });\r\n    });\r\n}\r\nexports.storeTempusRefresher = storeTempusRefresher;\r\n/**Updates all the open tabs */\r\nfunction updateOpenTabs() {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var tabs, tempusObject, tempusRefresher, tempusArrayDomains, j, obj;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0: return [4 /*yield*/, queryBrowserTabs({})];\r\n                case 1:\r\n                    tabs = _a.sent();\r\n                    return [4 /*yield*/, fetchTempusObject()];\r\n                case 2:\r\n                    tempusObject = _a.sent();\r\n                    return [4 /*yield*/, fetchTempusRefresher()];\r\n                case 3:\r\n                    tempusRefresher = _a.sent();\r\n                    tempusArrayDomains = [];\r\n                    for (j = 0; j < tempusObject.tempusArray.length; j++) {\r\n                        obj = tempusObject.tempusArray[j];\r\n                        tempusArrayDomains.push(obj.domain);\r\n                    }\r\n                    // If any of the tabsDomains do not have an entry in tempusArrayDomains, then add it to the list\r\n                    tabs.forEach(function (tab) {\r\n                        if (tab.url) {\r\n                            var domain = returnDomainFromURL(tab.url);\r\n                            var index = tempusArrayDomains.indexOf(domain);\r\n                            if (index == -1) {\r\n                                tempusObject.tempusArray.push({\r\n                                    active: tab.active,\r\n                                    domain: domain,\r\n                                    activatedAt: new Date().getTime(),\r\n                                    lapsed: 0\r\n                                });\r\n                            }\r\n                            else {\r\n                                // Set the tab to active\r\n                                if (tab.active) {\r\n                                    var el = tempusObject.tempusArray[index];\r\n                                    el.active = tab.active;\r\n                                    tempusObject.tempusArray.splice(index, 1, el);\r\n                                }\r\n                            }\r\n                        }\r\n                    });\r\n                    return [4 /*yield*/, storeTempusObject(tempusObject)];\r\n                case 4:\r\n                    _a.sent();\r\n                    return [2 /*return*/];\r\n            }\r\n        });\r\n    });\r\n}\r\nexports.updateOpenTabs = updateOpenTabs;\r\n// Alarms\r\n/**Creates the alarm */\r\nfunction createAlarm() {\r\n    createBrowserAlarm(exports.refreshAlarm, { delayInMinutes: exports.refreshDelayInMins }, refreshTimestamp);\r\n}\r\n/**Resets the alarms */\r\nfunction resetAlarm() {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0: return [4 /*yield*/, clearBrowserAlarm(exports.refreshAlarm)];\r\n                case 1:\r\n                    _a.sent();\r\n                    createAlarm();\r\n                    return [2 /*return*/];\r\n            }\r\n        });\r\n    });\r\n}\r\n/**Event handler that handles the alarm fire */\r\nfunction refreshTimestamp() {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var tempusRefresher, tempusObject;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0: return [4 /*yield*/, fetchTempusRefresher()];\r\n                case 1:\r\n                    tempusRefresher = _a.sent();\r\n                    tempusRefresher.refreshed_at = new Date().getTime();\r\n                    return [4 /*yield*/, storeTempusRefresher(tempusRefresher)];\r\n                case 2:\r\n                    _a.sent();\r\n                    return [4 /*yield*/, fetchTempusObject()];\r\n                case 3:\r\n                    tempusObject = _a.sent();\r\n                    tempusObject.tempusArray.forEach(function (tempusStruct) {\r\n                        if (tempusStruct.active) {\r\n                            tempusStruct.lapsed += tempusRefresher.refreshed_at - tempusStruct.activatedAt;\r\n                            tempusStruct.activatedAt = tempusRefresher.refreshed_at;\r\n                        }\r\n                    });\r\n                    return [4 /*yield*/, storeTempusObject(tempusObject)];\r\n                case 4:\r\n                    _a.sent();\r\n                    return [4 /*yield*/, resetAlarm()];\r\n                case 5:\r\n                    _a.sent();\r\n                    return [2 /*return*/];\r\n            }\r\n        });\r\n    });\r\n}\r\n/**Handle the first run */\r\nfunction onFirstLoad() {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0: return [4 /*yield*/, closePreviouslyUnclosedTabs()];\r\n                case 1:\r\n                    _a.sent();\r\n                    return [4 /*yield*/, updateOpenTabs()];\r\n                case 2:\r\n                    _a.sent();\r\n                    return [4 /*yield*/, resetAlarm()];\r\n                case 3:\r\n                    _a.sent();\r\n                    return [2 /*return*/];\r\n            }\r\n        });\r\n    });\r\n}\r\nexports.onFirstLoad = onFirstLoad;\r\n/**Deletes the storage */\r\nfunction __deleteStorage() {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0: return [4 /*yield*/, clearStorage()];\r\n                case 1:\r\n                    _a.sent();\r\n                    return [2 /*return*/];\r\n            }\r\n        });\r\n    });\r\n}\r\nexports.__deleteStorage = __deleteStorage;\r\n","\"use strict\";\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [0, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar commons = require(\"./commons\");\r\n/**Appends to the list if the object is not already present in the list */\r\nfunction appendToTempusObjectArray(object) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var tempusObject, found, i, temp;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0: return [4 /*yield*/, commons.fetchTempusObject()];\r\n                case 1:\r\n                    tempusObject = _a.sent();\r\n                    found = false;\r\n                    for (i = 0; i < tempusObject.tempusArray.length; i++) {\r\n                        temp = tempusObject.tempusArray[i];\r\n                        if (temp.domain === object.domain) {\r\n                            found = true;\r\n                            // Interchange the values\r\n                            if (temp.active) {\r\n                                // Don't change anything, since this is already being considered\r\n                            }\r\n                            else if (object.active) {\r\n                                temp.active = object.active;\r\n                                temp.activatedAt = object.activatedAt;\r\n                                if (object.lapsed > 0) {\r\n                                    temp.lapsed = object.lapsed | 0;\r\n                                }\r\n                                tempusObject.tempusArray[i] = temp;\r\n                            }\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (!found) {\r\n                        tempusObject.tempusArray.push(object);\r\n                    }\r\n                    return [4 /*yield*/, commons.storeTempusObject(tempusObject)];\r\n                case 2:\r\n                    _a.sent();\r\n                    return [2 /*return*/];\r\n            }\r\n        });\r\n    });\r\n}\r\n/**Sets the active */\r\nfunction toggleTabsActiveState(tempusTabs, active) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var object, allTabsDomains, activeDomains, i, availableTab;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0: return [4 /*yield*/, commons.fetchTempusObject()];\r\n                case 1:\r\n                    object = _a.sent();\r\n                    allTabsDomains = object.tempusArray.map(function (temp) {\r\n                        return temp.domain;\r\n                    });\r\n                    activeDomains = tempusTabs.map(function (temp) {\r\n                        return temp.domain;\r\n                    });\r\n                    for (i = 0; i < allTabsDomains.length; i++) {\r\n                        availableTab = allTabsDomains[i];\r\n                        if (activeDomains.indexOf(availableTab) > -1) {\r\n                            if (active) {\r\n                                object.tempusArray[i].active = true;\r\n                                object.tempusArray[i].activatedAt = new Date().getTime();\r\n                            }\r\n                            else {\r\n                                object.tempusArray[i].active = false;\r\n                                object.tempusArray[i].activatedAt = 0;\r\n                            }\r\n                        }\r\n                        else {\r\n                            object.tempusArray[i].active = false;\r\n                        }\r\n                    }\r\n                    return [4 /*yield*/, commons.storeTempusObject(object)];\r\n                case 2:\r\n                    _a.sent();\r\n                    return [2 /*return*/];\r\n            }\r\n        });\r\n    });\r\n}\r\n/**Handles a tab updation event of the browser */\r\nfunction handleTabUpdation(tabId, changeInfo, tab) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var newTab;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0: return [4 /*yield*/, commons.closePreviouslyUnclosedTabs()];\r\n                case 1:\r\n                    _a.sent();\r\n                    return [4 /*yield*/, commons.updateOpenTabs()];\r\n                case 2:\r\n                    _a.sent();\r\n                    if (changeInfo.status === \"complete\") {\r\n                        newTab = {\r\n                            domain: commons.returnDomainFromURL(tab.url),\r\n                            active: tab.active,\r\n                            lapsed: 0\r\n                        };\r\n                        if (newTab.active) {\r\n                            newTab.activatedAt = new Date().getTime();\r\n                        }\r\n                        appendToTempusObjectArray(newTab);\r\n                    }\r\n                    return [2 /*return*/];\r\n            }\r\n        });\r\n    });\r\n}\r\n/**Function that fetches all the available tabs and processes them */\r\nfunction recountAllActiveTabs() {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var temp, allTabs;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0: return [4 /*yield*/, commons.queryBrowserTabs({\r\n                        active: true\r\n                    })];\r\n                case 1:\r\n                    temp = _a.sent();\r\n                    allTabs = temp.map(function (tab) {\r\n                        var localTab = {\r\n                            domain: commons.returnDomainFromURL(tab.url),\r\n                            active: tab.active,\r\n                            lapsed: 0,\r\n                            activatedAt: 0\r\n                        };\r\n                        if (localTab.active) {\r\n                            localTab.activatedAt = new Date().getTime();\r\n                        }\r\n                        return localTab;\r\n                    });\r\n                    toggleTabsActiveState(allTabs, true);\r\n                    return [2 /*return*/];\r\n            }\r\n        });\r\n    });\r\n}\r\n// Create the event handler for onActivated\r\ncommons.addBrowserTabsOnActivatedHandler(recountAllActiveTabs);\r\n// Create the event handler for onRemoved\r\ncommons.addBrowserTabsOnRemovedHandler(recountAllActiveTabs);\r\n// Create the event handler for onUpdated\r\ncommons.addBrowserTabsOnUpdatedHandler(handleTabUpdation);\r\ncommons.onFirstLoad();\r\n"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzcmMvanMvY29tbW9ucy5qcyIsInNyYy9qcy9tYWluLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2aEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn07XHJcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XHJcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IHlbb3BbMF0gJiAyID8gXCJyZXR1cm5cIiA6IG9wWzBdID8gXCJ0aHJvd1wiIDogXCJuZXh0XCJdKSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFswLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLyoqU3RvcmVzIHRoZSBsaXN0IG9mIFVSTHMgKi9cclxuZXhwb3J0cy50ZW1wdXNPYmplY3RJRCA9IFwidGVtcHVzQXJyYXlcIjtcclxuZXhwb3J0cy50ZW1wdXNSZWZyZXNoZXJJRCA9IFwidGVtcHVzUmVmcmVzaGVyXCI7XHJcbmV4cG9ydHMucmVmcmVzaERlbGF5SW5NaW5zID0gKDEgLyA2MCk7XHJcbnZhciByZWZyZXNoRGVsYXlJbk1pbGxpU2Vjb25kcyA9IGV4cG9ydHMucmVmcmVzaERlbGF5SW5NaW5zICogNjAgKiAxMDAwO1xyXG5leHBvcnRzLnJlZnJlc2hBbGFybSA9IFwiQWxhcm1cIjtcclxudmFyIGZpcmVmb3hCcm93c2VyID0gJ2ZpcmVmb3gnO1xyXG52YXIgY2hyb21lQnJvd3NlciA9ICdjaHJvbWUnO1xyXG52YXIgYnJvd3Nlck5hbWU7XHJcbmlmIChuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXCJDaHJvbWVcIikgPiAtMSkge1xyXG4gICAgYnJvd3Nlck5hbWUgPSBjaHJvbWVCcm93c2VyO1xyXG59XHJcbmVsc2Uge1xyXG4gICAgYnJvd3Nlck5hbWUgPSBmaXJlZm94QnJvd3NlcjtcclxufVxyXG4vLyBsZXQgYnJvd3NlciA9IGNocm9tZTtcclxuLyoqUmV0cmlldmVzIHRoZSBzdG9yYWdlIHZhbHVlICovXHJcbmZ1bmN0aW9uIGdldFN0b3JhZ2UoKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoYnJvd3Nlck5hbWUgPT0gZmlyZWZveEJyb3dzZXIpKSByZXR1cm4gWzMgLypicmVhayovLCAyXTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBicm93c2VyLnN0b3JhZ2UubG9jYWwuZ2V0KCldO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcclxuICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYnJvd3Nlck5hbWUgPT0gY2hyb21lQnJvd3Nlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNocm9tZS5zdG9yYWdlLmxvY2FsLmdldChmdW5jdGlvbiAoaXRlbXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoaXRlbXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAzO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gWzIgLypyZXR1cm4qLywge31dO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxyXG4vKipTZXRzIHRoZSBzdG9yYWdlICovXHJcbmZ1bmN0aW9uIHNldFN0b3JhZ2Uoc3RvcmFnZU9iamVjdCkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKGJyb3dzZXJOYW1lID09IGZpcmVmb3hCcm93c2VyKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgYnJvd3Nlci5zdG9yYWdlLmxvY2FsLnNldChzdG9yYWdlT2JqZWN0KV07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDNdO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChicm93c2VyTmFtZSA9PSBjaHJvbWVCcm93c2VyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hyb21lLnN0b3JhZ2UubG9jYWwuc2V0KHN0b3JhZ2VPYmplY3QsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMztcclxuICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxyXG4vKipDbGVhcnMgdGhlIHN0b3JhZ2UgKi9cclxuZnVuY3Rpb24gY2xlYXJTdG9yYWdlKCkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKGJyb3dzZXJOYW1lID09IGZpcmVmb3hCcm93c2VyKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgYnJvd3Nlci5zdG9yYWdlLmxvY2FsLmNsZWFyKCldO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAzXTtcclxuICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYnJvd3Nlck5hbWUgPT0gY2hyb21lQnJvd3Nlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNocm9tZS5zdG9yYWdlLmxvY2FsLmNsZWFyKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMztcclxuICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxyXG4vKipBZGRzIGFuIGFsYXJtIHRvIHRoZSBhcHByb3ByaWF0ZSBicm93c2VyICovXHJcbmZ1bmN0aW9uIGNyZWF0ZUJyb3dzZXJBbGFybShhbGFybU5hbWUsIG9iaiwgbGlzdGVuZXIpIHtcclxuICAgIGlmIChicm93c2VyTmFtZSA9PSBmaXJlZm94QnJvd3Nlcikge1xyXG4gICAgICAgIGJyb3dzZXIuYWxhcm1zLmNyZWF0ZShhbGFybU5hbWUsIG9iaik7XHJcbiAgICAgICAgYnJvd3Nlci5hbGFybXMub25BbGFybS5hZGRMaXN0ZW5lcihsaXN0ZW5lcik7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChicm93c2VyTmFtZSA9PSBjaHJvbWVCcm93c2VyKSB7XHJcbiAgICAgICAgY2hyb21lLmFsYXJtcy5jcmVhdGUoYWxhcm1OYW1lLCBvYmopO1xyXG4gICAgICAgIGNocm9tZS5hbGFybXMub25BbGFybS5hZGRMaXN0ZW5lcihsaXN0ZW5lcik7XHJcbiAgICB9XHJcbn1cclxuLyoqQ2xlYXJzIHRoZSBicm93c2VyIGFsYXJtICovXHJcbmZ1bmN0aW9uIGNsZWFyQnJvd3NlckFsYXJtKGFsYXJtTmFtZSkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKGJyb3dzZXJOYW1lID09IGZpcmVmb3hCcm93c2VyKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgYnJvd3Nlci5hbGFybXMuY2xlYXIoYWxhcm1OYW1lKV07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDNdO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChicm93c2VyTmFtZSA9PSBjaHJvbWVCcm93c2VyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hyb21lLmFsYXJtcy5jbGVhcihhbGFybU5hbWUsIGZ1bmN0aW9uICh3YXNDbGVhcmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDM7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbMiAvKnJldHVybiovXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn1cclxuLyoqUmV0dXJucyBhbGwgdGhlIGJyb3dzZXIgdGFicyBvbiB0aGUgYmFzaXMgb2YgdGhlIHF1ZXJ5IG9iamVjdCAqL1xyXG5mdW5jdGlvbiBxdWVyeUJyb3dzZXJUYWJzKG9iaikge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKGJyb3dzZXJOYW1lID09IGZpcmVmb3hCcm93c2VyKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgYnJvd3Nlci50YWJzLnF1ZXJ5KG9iaildO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcclxuICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYnJvd3Nlck5hbWUgPT0gY2hyb21lQnJvd3Nlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNocm9tZS50YWJzLnF1ZXJ5KG9iaiwgZnVuY3Rpb24gKHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAzO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gWzIgLypyZXR1cm4qLywgW11dO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxyXG5leHBvcnRzLnF1ZXJ5QnJvd3NlclRhYnMgPSBxdWVyeUJyb3dzZXJUYWJzO1xyXG4vKipBdHRhY2hlcyB0aGUgZXZlbnQgaGFuZGxlciB0aGF0IGlzIGZpcmVkIHdoZW4gYSB0YWIgaXMgYWN0aXZhdGVkICovXHJcbmZ1bmN0aW9uIGFkZEJyb3dzZXJUYWJzT25BY3RpdmF0ZWRIYW5kbGVyKGNhbGxiYWNrKSB7XHJcbiAgICBpZiAoYnJvd3Nlck5hbWUgPT0gZmlyZWZveEJyb3dzZXIpIHtcclxuICAgICAgICBicm93c2VyLnRhYnMub25BY3RpdmF0ZWQuYWRkTGlzdGVuZXIoY2FsbGJhY2spO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoYnJvd3Nlck5hbWUgPT0gY2hyb21lQnJvd3Nlcikge1xyXG4gICAgICAgIGNocm9tZS50YWJzLm9uQWN0aXZhdGVkLmFkZExpc3RlbmVyKGNhbGxiYWNrKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLmFkZEJyb3dzZXJUYWJzT25BY3RpdmF0ZWRIYW5kbGVyID0gYWRkQnJvd3NlclRhYnNPbkFjdGl2YXRlZEhhbmRsZXI7XHJcbi8qKkF0dGFjaGVzIHRoZSBldmVudCBoYW5kbGVyIHRoYXQgaXMgZmlyZWQgd2hlbiBhIHRhYiBpcyByZW1vdmVkICovXHJcbmZ1bmN0aW9uIGFkZEJyb3dzZXJUYWJzT25SZW1vdmVkSGFuZGxlcihjYWxsYmFjaykge1xyXG4gICAgaWYgKGJyb3dzZXJOYW1lID09IGZpcmVmb3hCcm93c2VyKSB7XHJcbiAgICAgICAgYnJvd3Nlci50YWJzLm9uUmVtb3ZlZC5hZGRMaXN0ZW5lcihjYWxsYmFjayk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChicm93c2VyTmFtZSA9PSBjaHJvbWVCcm93c2VyKSB7XHJcbiAgICAgICAgY2hyb21lLnRhYnMub25SZW1vdmVkLmFkZExpc3RlbmVyKGNhbGxiYWNrKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLmFkZEJyb3dzZXJUYWJzT25SZW1vdmVkSGFuZGxlciA9IGFkZEJyb3dzZXJUYWJzT25SZW1vdmVkSGFuZGxlcjtcclxuLyoqQXR0YWNoZXMgdGhlIGV2ZW50IGhhbmRsZXIgdGhhdCBpcyBmaXJlZCB3aGVuIGEgdGFiIGlzIHVwZGF0ZWQgKi9cclxuZnVuY3Rpb24gYWRkQnJvd3NlclRhYnNPblVwZGF0ZWRIYW5kbGVyKGNhbGxiYWNrKSB7XHJcbiAgICBpZiAoYnJvd3Nlck5hbWUgPT0gZmlyZWZveEJyb3dzZXIpIHtcclxuICAgICAgICBicm93c2VyLnRhYnMub25VcGRhdGVkLmFkZExpc3RlbmVyKGNhbGxiYWNrKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGJyb3dzZXJOYW1lID09IGNocm9tZUJyb3dzZXIpIHtcclxuICAgICAgICBjaHJvbWUudGFicy5vblVwZGF0ZWQuYWRkTGlzdGVuZXIoY2FsbGJhY2spO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuYWRkQnJvd3NlclRhYnNPblVwZGF0ZWRIYW5kbGVyID0gYWRkQnJvd3NlclRhYnNPblVwZGF0ZWRIYW5kbGVyO1xyXG4vKipSZXR1cm5zIHRoZSB0ZW1wdXMgb2JqZWN0ICovXHJcbmZ1bmN0aW9uIGZldGNoVGVtcHVzT2JqZWN0KCkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBzdG9yYWdlT2JqZWN0O1xyXG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBnZXRTdG9yYWdlKCldO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgIHN0b3JhZ2VPYmplY3QgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEhc3RvcmFnZU9iamVjdFtleHBvcnRzLnRlbXB1c09iamVjdElEXSkgcmV0dXJuIFszIC8qYnJlYWsqLywgM107XHJcbiAgICAgICAgICAgICAgICAgICAgc3RvcmFnZU9iamVjdFtleHBvcnRzLnRlbXB1c09iamVjdElEXSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGV4cG9ydHMudGVtcHVzT2JqZWN0SUQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXB1c0FycmF5OiBbXVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV3JpdGUgdGhlIG9iamVjdCB0byB0aGUgc3RvcmFnZVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHNldFN0b3JhZ2Uoc3RvcmFnZU9iamVjdCldO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdyaXRlIHRoZSBvYmplY3QgdG8gdGhlIHN0b3JhZ2VcclxuICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAzO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gWzQgLyp5aWVsZCovLCBnZXRTdG9yYWdlKCldO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICAgICAgICAgIHN0b3JhZ2VPYmplY3QgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHN0b3JhZ2VPYmplY3RbZXhwb3J0cy50ZW1wdXNPYmplY3RJRF1dO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxyXG5leHBvcnRzLmZldGNoVGVtcHVzT2JqZWN0ID0gZmV0Y2hUZW1wdXNPYmplY3Q7XHJcbi8qKlJldHVybnMgdGhlIHRlbXB1cyByZWZyZXNoZXIgb2JqZWN0ICovXHJcbmZ1bmN0aW9uIGZldGNoVGVtcHVzUmVmcmVzaGVyKCkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBzdG9yYWdlT2JqZWN0O1xyXG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBnZXRTdG9yYWdlKCldO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgIHN0b3JhZ2VPYmplY3QgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEhc3RvcmFnZU9iamVjdFtleHBvcnRzLnRlbXB1c1JlZnJlc2hlcklEXSkgcmV0dXJuIFszIC8qYnJlYWsqLywgM107XHJcbiAgICAgICAgICAgICAgICAgICAgc3RvcmFnZU9iamVjdFtleHBvcnRzLnRlbXB1c1JlZnJlc2hlcklEXSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGV4cG9ydHMudGVtcHVzUmVmcmVzaGVySUQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hlZF9hdDogMFxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV3JpdGUgdGhlIG9iamVjdCB0byB0aGUgc3RvcmFnZVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHNldFN0b3JhZ2Uoc3RvcmFnZU9iamVjdCldO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdyaXRlIHRoZSBvYmplY3QgdG8gdGhlIHN0b3JhZ2VcclxuICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAzO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gWzQgLyp5aWVsZCovLCBnZXRTdG9yYWdlKCldO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICAgICAgICAgIHN0b3JhZ2VPYmplY3QgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHN0b3JhZ2VPYmplY3RbZXhwb3J0cy50ZW1wdXNSZWZyZXNoZXJJRF1dO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxyXG5leHBvcnRzLmZldGNoVGVtcHVzUmVmcmVzaGVyID0gZmV0Y2hUZW1wdXNSZWZyZXNoZXI7XHJcbi8qKkNoZWNrcyBpZiB0aGVyZSBhcmUgYW55IHVuY2xvc2VkIHRhYnMgYW5kIGNsb3NlcyB0aGVtICovXHJcbmZ1bmN0aW9uIGNsb3NlUHJldmlvdXNseVVuY2xvc2VkVGFicygpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdGVtcHVzT2JqZWN0LCB0ZW1wdXNSZWZyZXNoZXIsIGN1cnJlbnRUaW1lc3RhbXAsIHRpbWVEZWxheTtcclxuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgZmV0Y2hUZW1wdXNPYmplY3QoKV07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgdGVtcHVzT2JqZWN0ID0gX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGZldGNoVGVtcHVzUmVmcmVzaGVyKCldO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgIHRlbXB1c1JlZnJlc2hlciA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VGltZXN0YW1wID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRlbXB1c1JlZnJlc2hlci5yZWZyZXNoZWRfYXQgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCB0aW1lIHRoaXMgaXMgcnVubmluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRpbWVEZWxheSA9IGN1cnJlbnRUaW1lc3RhbXAgLSB0ZW1wdXNSZWZyZXNoZXIucmVmcmVzaGVkX2F0O1xyXG4gICAgICAgICAgICAgICAgICAgIC8qIEl0ZXJhdGUgb3ZlciBhbGwgdGhlIGF2YWlsYWJsZSB0ZW1wdXMgb2JqZWN0cyBhbmQgc2V0IHRoZWlyIGFjdGl2ZSB0byBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICAvKiBhbmQgaW5jcmVhc2UgdGhlaXIgZHVyYXRpb24gYnkgcmVmcmVzaERlbGF5SW5NaW5zICogNjAwMFxyXG4gICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgdGVtcHVzT2JqZWN0LnRlbXB1c0FycmF5LmZvckVhY2goZnVuY3Rpb24gKHRlbXB1c1N0cnVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGVtcHVzU3RydWN0LmFjdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcHVzU3RydWN0LmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVEZWxheSA+IHJlZnJlc2hEZWxheUluTWlsbGlTZWNvbmRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGltZSBkZWxheSBpcyBncmVhdGVyLCB0aGVuIHRoZSBtYXggaW5jcmVtZW50IGNhbiBiZSB0aGUgcmVmcmVzaCBkZWxheVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXB1c1N0cnVjdC5sYXBzZWQgKz0gcmVmcmVzaERlbGF5SW5NaWxsaVNlY29uZHM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aW1lIGRlbGF5IGlzIGxvd2VyLCB0aGVuIHNldCBpdCB0byB0aW1lIGRlbGF5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcHVzU3RydWN0LmxhcHNlZCArPSB0aW1lRGVsYXk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBzdG9yZVRlbXB1c09iamVjdCh0ZW1wdXNPYmplY3QpXTtcclxuICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgc3RvcmVUZW1wdXNSZWZyZXNoZXIodGVtcHVzUmVmcmVzaGVyKV07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn1cclxuZXhwb3J0cy5jbG9zZVByZXZpb3VzbHlVbmNsb3NlZFRhYnMgPSBjbG9zZVByZXZpb3VzbHlVbmNsb3NlZFRhYnM7XHJcbi8qKlJldHVybnMgZG9tYWluIGZyb20gYSBwYXNzZWQgVVJMICovXHJcbmZ1bmN0aW9uIHJldHVybkRvbWFpbkZyb21VUkwodXJsKSB7XHJcbiAgICB2YXIgZG9tYWluID0gJyc7XHJcbiAgICBpZiAoIXVybCkge1xyXG4gICAgICAgIHJldHVybiBkb21haW47XHJcbiAgICB9XHJcbiAgICBpZiAodXJsLnN0YXJ0c1dpdGgoXCJodHRwXCIpKSB7XHJcbiAgICAgICAgdmFyIHRlbXAgPSB1cmwuc3BsaXQoXCIvL1wiKTtcclxuICAgICAgICBkb21haW4gPSB0ZW1wWzBdICsgXCIvL1wiICsgdGVtcFsxXS5zcGxpdChcIi9cIilbMF07XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBkb21haW4gPSB1cmw7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZG9tYWluO1xyXG59XHJcbmV4cG9ydHMucmV0dXJuRG9tYWluRnJvbVVSTCA9IHJldHVybkRvbWFpbkZyb21VUkw7XHJcbi8qKlN0b3JlcyB0aGUgdGVtcHVzIG9iamVjdCBpbiB0aGUgc3RvcmFnZSAqL1xyXG5mdW5jdGlvbiBzdG9yZVRlbXB1c09iamVjdChvYmopIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgbG9jYWxPYmo7XHJcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxPYmogPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICBsb2NhbE9ialtleHBvcnRzLnRlbXB1c09iamVjdElEXSA9IG9iajtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBzZXRTdG9yYWdlKGxvY2FsT2JqKV07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn1cclxuZXhwb3J0cy5zdG9yZVRlbXB1c09iamVjdCA9IHN0b3JlVGVtcHVzT2JqZWN0O1xyXG4vKipTdG9yZXMgdGhlIHRlbXB1cyByZWZyZXNoZXIgaW4gdGhlIHN0b3JhZ2UgKi9cclxuZnVuY3Rpb24gc3RvcmVUZW1wdXNSZWZyZXNoZXIob2JqKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGxvY2FsT2JqO1xyXG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsT2JqID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxPYmpbZXhwb3J0cy50ZW1wdXNSZWZyZXNoZXJJRF0gPSBvYmo7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgc2V0U3RvcmFnZShsb2NhbE9iaildO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcbmV4cG9ydHMuc3RvcmVUZW1wdXNSZWZyZXNoZXIgPSBzdG9yZVRlbXB1c1JlZnJlc2hlcjtcclxuLyoqVXBkYXRlcyBhbGwgdGhlIG9wZW4gdGFicyAqL1xyXG5mdW5jdGlvbiB1cGRhdGVPcGVuVGFicygpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdGFicywgdGVtcHVzT2JqZWN0LCB0ZW1wdXNSZWZyZXNoZXIsIHRlbXB1c0FycmF5RG9tYWlucywgaiwgb2JqO1xyXG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBxdWVyeUJyb3dzZXJUYWJzKHt9KV07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgdGFicyA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBmZXRjaFRlbXB1c09iamVjdCgpXTtcclxuICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICB0ZW1wdXNPYmplY3QgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZmV0Y2hUZW1wdXNSZWZyZXNoZXIoKV07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgdGVtcHVzUmVmcmVzaGVyID0gX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRlbXB1c0FycmF5RG9tYWlucyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCB0ZW1wdXNPYmplY3QudGVtcHVzQXJyYXkubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gdGVtcHVzT2JqZWN0LnRlbXB1c0FycmF5W2pdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wdXNBcnJheURvbWFpbnMucHVzaChvYmouZG9tYWluKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgYW55IG9mIHRoZSB0YWJzRG9tYWlucyBkbyBub3QgaGF2ZSBhbiBlbnRyeSBpbiB0ZW1wdXNBcnJheURvbWFpbnMsIHRoZW4gYWRkIGl0IHRvIHRoZSBsaXN0XHJcbiAgICAgICAgICAgICAgICAgICAgdGFicy5mb3JFYWNoKGZ1bmN0aW9uICh0YWIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhYi51cmwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkb21haW4gPSByZXR1cm5Eb21haW5Gcm9tVVJMKHRhYi51cmwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gdGVtcHVzQXJyYXlEb21haW5zLmluZGV4T2YoZG9tYWluKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXB1c09iamVjdC50ZW1wdXNBcnJheS5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlOiB0YWIuYWN0aXZlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb21haW46IGRvbWFpbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZhdGVkQXQ6IG5ldyBEYXRlKCkuZ2V0VGltZSgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXBzZWQ6IDBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNldCB0aGUgdGFiIHRvIGFjdGl2ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YWIuYWN0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbCA9IHRlbXB1c09iamVjdC50ZW1wdXNBcnJheVtpbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsLmFjdGl2ZSA9IHRhYi5hY3RpdmU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXB1c09iamVjdC50ZW1wdXNBcnJheS5zcGxpY2UoaW5kZXgsIDEsIGVsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBzdG9yZVRlbXB1c09iamVjdCh0ZW1wdXNPYmplY3QpXTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxyXG5leHBvcnRzLnVwZGF0ZU9wZW5UYWJzID0gdXBkYXRlT3BlblRhYnM7XHJcbi8vIEFsYXJtc1xyXG4vKipDcmVhdGVzIHRoZSBhbGFybSAqL1xyXG5mdW5jdGlvbiBjcmVhdGVBbGFybSgpIHtcclxuICAgIGNyZWF0ZUJyb3dzZXJBbGFybShleHBvcnRzLnJlZnJlc2hBbGFybSwgeyBkZWxheUluTWludXRlczogZXhwb3J0cy5yZWZyZXNoRGVsYXlJbk1pbnMgfSwgcmVmcmVzaFRpbWVzdGFtcCk7XHJcbn1cclxuLyoqUmVzZXRzIHRoZSBhbGFybXMgKi9cclxuZnVuY3Rpb24gcmVzZXRBbGFybSgpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgY2xlYXJCcm93c2VyQWxhcm0oZXhwb3J0cy5yZWZyZXNoQWxhcm0pXTtcclxuICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlQWxhcm0oKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcbi8qKkV2ZW50IGhhbmRsZXIgdGhhdCBoYW5kbGVzIHRoZSBhbGFybSBmaXJlICovXHJcbmZ1bmN0aW9uIHJlZnJlc2hUaW1lc3RhbXAoKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHRlbXB1c1JlZnJlc2hlciwgdGVtcHVzT2JqZWN0O1xyXG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBmZXRjaFRlbXB1c1JlZnJlc2hlcigpXTtcclxuICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICB0ZW1wdXNSZWZyZXNoZXIgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVtcHVzUmVmcmVzaGVyLnJlZnJlc2hlZF9hdCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHN0b3JlVGVtcHVzUmVmcmVzaGVyKHRlbXB1c1JlZnJlc2hlcildO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBmZXRjaFRlbXB1c09iamVjdCgpXTtcclxuICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgICAgICB0ZW1wdXNPYmplY3QgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVtcHVzT2JqZWN0LnRlbXB1c0FycmF5LmZvckVhY2goZnVuY3Rpb24gKHRlbXB1c1N0cnVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGVtcHVzU3RydWN0LmFjdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcHVzU3RydWN0LmxhcHNlZCArPSB0ZW1wdXNSZWZyZXNoZXIucmVmcmVzaGVkX2F0IC0gdGVtcHVzU3RydWN0LmFjdGl2YXRlZEF0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcHVzU3RydWN0LmFjdGl2YXRlZEF0ID0gdGVtcHVzUmVmcmVzaGVyLnJlZnJlc2hlZF9hdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHN0b3JlVGVtcHVzT2JqZWN0KHRlbXB1c09iamVjdCldO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCByZXNldEFsYXJtKCldO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OlxyXG4gICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcbi8qKkhhbmRsZSB0aGUgZmlyc3QgcnVuICovXHJcbmZ1bmN0aW9uIG9uRmlyc3RMb2FkKCkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBjbG9zZVByZXZpb3VzbHlVbmNsb3NlZFRhYnMoKV07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHVwZGF0ZU9wZW5UYWJzKCldO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCByZXNldEFsYXJtKCldO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcbmV4cG9ydHMub25GaXJzdExvYWQgPSBvbkZpcnN0TG9hZDtcclxuLyoqRGVsZXRlcyB0aGUgc3RvcmFnZSAqL1xyXG5mdW5jdGlvbiBfX2RlbGV0ZVN0b3JhZ2UoKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIGNsZWFyU3RvcmFnZSgpXTtcclxuICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxyXG5leHBvcnRzLl9fZGVsZXRlU3RvcmFnZSA9IF9fZGVsZXRlU3RvcmFnZTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn07XHJcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XHJcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IHlbb3BbMF0gJiAyID8gXCJyZXR1cm5cIiA6IG9wWzBdID8gXCJ0aHJvd1wiIDogXCJuZXh0XCJdKSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFswLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIGNvbW1vbnMgPSByZXF1aXJlKFwiLi9jb21tb25zXCIpO1xyXG4vKipBcHBlbmRzIHRvIHRoZSBsaXN0IGlmIHRoZSBvYmplY3QgaXMgbm90IGFscmVhZHkgcHJlc2VudCBpbiB0aGUgbGlzdCAqL1xyXG5mdW5jdGlvbiBhcHBlbmRUb1RlbXB1c09iamVjdEFycmF5KG9iamVjdCkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB0ZW1wdXNPYmplY3QsIGZvdW5kLCBpLCB0ZW1wO1xyXG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBjb21tb25zLmZldGNoVGVtcHVzT2JqZWN0KCldO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgIHRlbXB1c09iamVjdCA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0ZW1wdXNPYmplY3QudGVtcHVzQXJyYXkubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcCA9IHRlbXB1c09iamVjdC50ZW1wdXNBcnJheVtpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRlbXAuZG9tYWluID09PSBvYmplY3QuZG9tYWluKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbnRlcmNoYW5nZSB0aGUgdmFsdWVzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGVtcC5hY3RpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBjaGFuZ2UgYW55dGhpbmcsIHNpbmNlIHRoaXMgaXMgYWxyZWFkeSBiZWluZyBjb25zaWRlcmVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChvYmplY3QuYWN0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcC5hY3RpdmUgPSBvYmplY3QuYWN0aXZlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXAuYWN0aXZhdGVkQXQgPSBvYmplY3QuYWN0aXZhdGVkQXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9iamVjdC5sYXBzZWQgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXAubGFwc2VkID0gb2JqZWN0LmxhcHNlZCB8IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXB1c09iamVjdC50ZW1wdXNBcnJheVtpXSA9IHRlbXA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWZvdW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXB1c09iamVjdC50ZW1wdXNBcnJheS5wdXNoKG9iamVjdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGNvbW1vbnMuc3RvcmVUZW1wdXNPYmplY3QodGVtcHVzT2JqZWN0KV07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn1cclxuLyoqU2V0cyB0aGUgYWN0aXZlICovXHJcbmZ1bmN0aW9uIHRvZ2dsZVRhYnNBY3RpdmVTdGF0ZSh0ZW1wdXNUYWJzLCBhY3RpdmUpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgb2JqZWN0LCBhbGxUYWJzRG9tYWlucywgYWN0aXZlRG9tYWlucywgaSwgYXZhaWxhYmxlVGFiO1xyXG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBjb21tb25zLmZldGNoVGVtcHVzT2JqZWN0KCldO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdCA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICBhbGxUYWJzRG9tYWlucyA9IG9iamVjdC50ZW1wdXNBcnJheS5tYXAoZnVuY3Rpb24gKHRlbXApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRlbXAuZG9tYWluO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZURvbWFpbnMgPSB0ZW1wdXNUYWJzLm1hcChmdW5jdGlvbiAodGVtcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGVtcC5kb21haW47XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGFsbFRhYnNEb21haW5zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF2YWlsYWJsZVRhYiA9IGFsbFRhYnNEb21haW5zW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aXZlRG9tYWlucy5pbmRleE9mKGF2YWlsYWJsZVRhYikgPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC50ZW1wdXNBcnJheVtpXS5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC50ZW1wdXNBcnJheVtpXS5hY3RpdmF0ZWRBdCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0LnRlbXB1c0FycmF5W2ldLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC50ZW1wdXNBcnJheVtpXS5hY3RpdmF0ZWRBdCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QudGVtcHVzQXJyYXlbaV0uYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgY29tbW9ucy5zdG9yZVRlbXB1c09iamVjdChvYmplY3QpXTtcclxuICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxyXG4vKipIYW5kbGVzIGEgdGFiIHVwZGF0aW9uIGV2ZW50IG9mIHRoZSBicm93c2VyICovXHJcbmZ1bmN0aW9uIGhhbmRsZVRhYlVwZGF0aW9uKHRhYklkLCBjaGFuZ2VJbmZvLCB0YWIpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgbmV3VGFiO1xyXG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBjb21tb25zLmNsb3NlUHJldmlvdXNseVVuY2xvc2VkVGFicygpXTtcclxuICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgY29tbW9ucy51cGRhdGVPcGVuVGFicygpXTtcclxuICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYW5nZUluZm8uc3RhdHVzID09PSBcImNvbXBsZXRlXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3VGFiID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9tYWluOiBjb21tb25zLnJldHVybkRvbWFpbkZyb21VUkwodGFiLnVybCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmU6IHRhYi5hY3RpdmUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXBzZWQ6IDBcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1RhYi5hY3RpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1RhYi5hY3RpdmF0ZWRBdCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwcGVuZFRvVGVtcHVzT2JqZWN0QXJyYXkobmV3VGFiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxyXG4vKipGdW5jdGlvbiB0aGF0IGZldGNoZXMgYWxsIHRoZSBhdmFpbGFibGUgdGFicyBhbmQgcHJvY2Vzc2VzIHRoZW0gKi9cclxuZnVuY3Rpb24gcmVjb3VudEFsbEFjdGl2ZVRhYnMoKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHRlbXAsIGFsbFRhYnM7XHJcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIGNvbW1vbnMucXVlcnlCcm93c2VyVGFicyh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZTogdHJ1ZVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXTtcclxuICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICB0ZW1wID0gX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFsbFRhYnMgPSB0ZW1wLm1hcChmdW5jdGlvbiAodGFiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsb2NhbFRhYiA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbWFpbjogY29tbW9ucy5yZXR1cm5Eb21haW5Gcm9tVVJMKHRhYi51cmwpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlOiB0YWIuYWN0aXZlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFwc2VkOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZhdGVkQXQ6IDBcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvY2FsVGFiLmFjdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxUYWIuYWN0aXZhdGVkQXQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxUYWI7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9nZ2xlVGFic0FjdGl2ZVN0YXRlKGFsbFRhYnMsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn1cclxuLy8gQ3JlYXRlIHRoZSBldmVudCBoYW5kbGVyIGZvciBvbkFjdGl2YXRlZFxyXG5jb21tb25zLmFkZEJyb3dzZXJUYWJzT25BY3RpdmF0ZWRIYW5kbGVyKHJlY291bnRBbGxBY3RpdmVUYWJzKTtcclxuLy8gQ3JlYXRlIHRoZSBldmVudCBoYW5kbGVyIGZvciBvblJlbW92ZWRcclxuY29tbW9ucy5hZGRCcm93c2VyVGFic09uUmVtb3ZlZEhhbmRsZXIocmVjb3VudEFsbEFjdGl2ZVRhYnMpO1xyXG4vLyBDcmVhdGUgdGhlIGV2ZW50IGhhbmRsZXIgZm9yIG9uVXBkYXRlZFxyXG5jb21tb25zLmFkZEJyb3dzZXJUYWJzT25VcGRhdGVkSGFuZGxlcihoYW5kbGVUYWJVcGRhdGlvbik7XHJcbmNvbW1vbnMub25GaXJzdExvYWQoKTtcclxuIl19"}